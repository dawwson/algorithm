> 풀이 날짜 : 2025.09.01  
> 문제 유형 : Array, Binary Search, Divide and Conquer  
> 문제 제목 : 4. Median of Two Sorted Arrays  
> 문제 링크 : https://leetcode.com/problems/median-of-two-sorted-arrays/description/

### Intuition

- 두 개의 정렬된 배열이 주어졌을 때, 두 배열의 중앙값(median)을 구하는 문제이다.

  쉽게 말하면 두 배열을 합쳐서 다시 정렬했을 때의 중앙값이다.

  - 합친 배열의 크기가 짝수라면 두 개의 중앙값의 평균값을 반환하고, 홀수라면 중앙값을 반환한다.

  - 두 배열의 크기를 각각 m, n이라고 할 때 시간복잡도는 `O(log (m+n))`이어야 하는 조건이 있다.

- 두 가지 접근 방법을 떠올려 보았다.

  1. Brute Force: 합치기 + 재정렬하기

     - 두 배열이 정렬된 배열임을 활용하지 않고 단순하게 합친 후 재정렬하기,
       또는 두 배열이 정렬되어 있으므로 중앙값까지만 합치기

  2. Binary Search
     - 각 배열을 반으로 나눴을 때 왼쪽/오른족 절반의 최대/최소는 바로 알 수 있으므로 배열을 합치지 않고 중앙값 계산이 가능하다. 중앙값은 왼쪽/오른쪽의 경계값에서 결정된다.
     - **[ _전체 왼쪽 절반의 원소 ≤ 전체 오른쪽 절반의 원소_ ]**를 보장하기 위해, 두 배열의 경계끼리 교차 비교하여 **[ _왼쪽 절반 최대값 ≤ 오른쪽 절반 최소값_ ]**을 만족하는지 확인한다.

### Approach

#### 1. Brute Force

- 새로운 배열(merged)에 두 배열을 합친 후 오름차순으로 정렬한다.

- 배열의 크기(짝수/홀수)에 따라 중앙값을 계산하여 반환한다.

#### 2. Binary Search

- 항상 num1이 더 짧은 배열이 되도록 swap 해준다.
  (＊Binary Search를 짧은 배열에서만 수행해야 효율적이기 때문)
- m, n에 배열의 길이를 저장하고, left, right에 num1에서 이진 탐색 범위를 초기화한다.
- left가 right 보다 작거나 같으면 반복한다.
  - `i`: nums1에서 자르는 위치 (왼쪽 절반 원소 개수)
  - `j`: num2에서 자르는 위치 (전체 왼쪽 절반 길이 맞추기)
  - `maxLeft1`: nums1 왼쪽 최대
  - `minRight1`: nums1 오른쪽 최소
  - `maxLeft2`: nums2 왼쪽 최대
  - `minRight2`: nums2 오른쪽 최소
  - 중앙값 결정 조건(왼쪽 절반 최대 ≦ 오른쪽 절반 최소)을 만족하면 홀수/짝수 길이에 따라 중앙값을 계산한다.
  - 분할 조건 불만족 시, Binary Search를 이동한다.
- 배열이 정렬되지 않았거나 잘못된 입력일 때의 예외처리를 한다.

### Complexity

- Time complexity:
  1. Brute Force: `O((m+n) * log(m+n))`
     - 배열을 합치는 데에서 O(m+n),
       정렬에서 O((m+n) \* log(m+n)),
       중앙값을 찾는 데에서 O(1)
     - 종합적으로 O((m+n) \* log(m+n))이다.
       (＊JavaScript에서 sort는 일반적으로 Timsort이므로 O(k log k)이다.)
  2. Binary Search: `O(log(min(m, n))`
     - Binary Search를 짧은 배열에서 수행하고, 한 번의 탐색마다 O(1)의 연산만 수행한다.
- Space complexity:
  1. Brute Force: `O(m+n)`
  2. Binary Search: `O(1)`

### Code (TS)

#### 1. Brute Force

```ts
function findMedianSortedArrays(nums1: number[], nums2: number[]): number {
  const merged = [...nums1, ...nums2];
  merged.sort((a, b) => a - b);

  if (merged.length % 2 === 0) {
    const m1 = merged.length / 2 - 1;
    const m2 = merged.length / 2;
    return (merged[m1] + merged[m2]) / 2;
  } else {
    const m = Math.floor(merged.length / 2);
    return merged[m];
  }
}
```

#### 2. Binary Search

```ts
function findMedianSortedArrays(nums1: number[], nums2: number[]): number {
  if (nums1.length > nums2.length) {
    // 항상 nums1이 더 짧은 배열이 되도록 swap
    return findMedianSortedArrays(nums2, nums1);
  }

  const m = nums1.length;
  const n = nums2.length;
  let left = 0,
    right = m;

  while (left <= right) {
    const i = Math.floor((left + right) / 2); // nums1에서 자르는 위치
    const j = Math.floor((m + n + 1) / 2) - i; // nums2에서 자르는 위치

    const maxLeft1 = i === 0 ? -Infinity : nums1[i - 1];
    const minRight1 = i === m ? Infinity : nums1[i];
    const maxLeft2 = j === 0 ? -Infinity : nums2[j - 1];
    const minRight2 = j === n ? Infinity : nums2[j];

    if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {
      if ((m + n) % 2 === 0) {
        return (
          (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2
        );
      } else {
        return Math.max(maxLeft1, maxLeft2);
      }
    } else if (maxLeft1 > minRight2) {
      right = i - 1; // 왼쪽으로 이동
    } else {
      left = i + 1; // 오른쪽으로 이동
    }
  }

  throw new Error("Input arrays are not sorted properly.");
}
```
