> 풀이 날짜 : 2025.09.02
> 문제 유형 : Two Pointers, String, Dynamic Programming
> 문제 제목 : 5. Longest Palindromic Substring
> 문제 링크 : https://leetcode.com/problems/longest-palindromic-substring/description/

### Intuition

- 주어진 문자열 안에서 가장 긴 팰린드롬(Palindrome, 앞으로 읽거나 뒤로 읽어도 글자, 숫자, 문장 등이 똑같은 경우) 부분 문자열을 찾는 문제이다.

- 세 가지 문제 해결 방법을 생각해보았다.

  1. Brute Force (완전 탐색) ❌

     - 모든 부분 문자열을 만들고, 팰린드롬인지 검사한다.

     - 길이가 n인 문자열에서 가능한 전체 부분 문자열을 구하는 데에 O(n²), 팰린드롬 여부를 확인하는 데에 Two Pointer로 해도 O(n)이다. 종합적으로 보면 시간 복잡도는 O(n³)이 된다.
     - 문제 제약조건에 따르면 길이가 주어진 문자열의 길이가 1000 이하인데, 아주 긴 문자열이 입력으로 들어오면 `TLE(Time Limit Exceeded)`에 걸린다.

  2. Expand Around Center (중심 확장법) ✅

     - 중심(`i` 또는 `i, i+1`)을 기준으로 좌우 확장하고 가장 긴 팰린드롬을 업데이트한다.

     - 홀수 길이 팰린드롬과 짝수 길이 팰린드롬을 나눠서 생각한다.

     - 문자열의 모든 인덱스를 중심으로 잡고, 양쪽으로 투포인터를 확장하면서 가장 긴 팰린드롬을 찾는다.

  3. Dynamic Programming ✅

     - 문자열 `s[i..j]`(i번째 문자부터 j번째 문자까지)가 팰린드롬인지 여부를 DP 테이블에 저장한다.

     - 길이가 2 이하이거나, 그 내부(`s[i+1..j-1]`)가 팰린드롬이면 true로 저장한다.

<span style="color:#808080">(Manacher's Algorithm 도 있다고 하는데, ~~나중에 찾아보기로 하자...~~)</span>

### Approach

#### 1. Expand Around Center

- `start`: 현재까지 찾은 가장 긴 팰린드롬의 시작 인덱스

  `maxLen`: 해당 팰린드롬의 길이

- 확장 함수(expand)를 정의한다.

  - left, right를 중심으로 잡고, 양쪽 문자가 같으면 계속 확장한다.
    더 긴 팰린드롬을 발견하면 start, maxLen을 갱신한다.

- 모든 인덱스를 중심으로 확장한다.

  - 중심이 한 글자인 홀수 길이의 팰린드롬, 중심이 두 글자인 짝수 길이의 팰린드롬을 나눠서 확장한다.

- 가장 긴 팰린드롬 부분 문자열을 잘라서 반환한다.

#### 2. Dynamic Programming

- dp 테이블을 정의한다.

  - `dp[i][j] = true`면 문자열 `s[i..j]`가 팰린드롬이라는 뜻이다.

  - 처음에는 전부 false로 초기화한다.

  - 길이가 1인 부분 문자열은 모두 팰린드롬이므로 true로 초기화한다.

- 부분 문자열의 길이를 늘려가며 팰린드롬인지 검사한다.

  - 양 끝이 같고(`s[i] === s[j]`) 그 내부가 팰린드롬이면(`dp[i+1][j-1]`), 팰린드롬이다. (두 글자면 바로 팰린드롬)

  - 최장 길이(maxLen)를 갱신하고 이때의 시작 인덱스(start)를 저장한다.

- 가장 긴 팰린드롬 부분 문자열을 잘라서 반환한다.

### Complexity

- Time complexity:

  1. Expand Around Center: `O(n²)`

     - 각 중심에서 확장은 최악의 경우 O(n), 중심의 개수는 `n`(홀수 길이 팰린드롬) + `n+1`(짝수 길이 팰린드롬) = `2n - 1`이므로, 전체 시간 복잡도는 O(n²)이다.

  2. Dynamic Programming: `O(n²)`

     - dp 테이블의 크기가 n²개이고, 각 칸을 채우는 데에 O(1) 시간이 걸리므로 O(n²)이다.

     - Dynamic Programming 방식은 부분 문자열마다 새로 팰린드롬 검사를 하는 게 아니라, 이전 계산 결과(`dp[i+1][j-1]`)를 재활용하기 때문에 O(n²)으로 줄어든다.

- Space complexity:

  1. Expand Around Center: `O(1)`

  2. Dynamic Programming: `O(n²)`

### Code (TS)

#### 1. Expand Around Center

```ts
function longestPalindrome(s: string): string {
  if (s.length < 2) return s;

  let start = 0,
    maxLen = 1;

  function expand(left: number, right: number): void {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
      if (right - left + 1 > maxLen) {
        start = left;
        maxLen = right - left + 1;
      }
      left--;
      right++;
    }
  }

  for (let i = 0; i < s.length; i++) {
    expand(i, i); // 홀수 길이
    expand(i, i + 1); // 짝수 길이
  }

  return s.substring(start, start + maxLen);
}
```

#### 2. Dynamic Programming

```ts
// Dynamic Programming
function longestPalindrome(s: string): string {
  const n = s.length;
  if (n < 2) return s;

  // dp[i][j] = s[i..j]가 팰린드롬인지 여부
  const dp: boolean[][] = Array.from({ length: n }, () => Array(n).fill(false));

  let start = 0;
  let maxLen = 1;

  // 1. 길이 1인 부분 문자열은 모두 팰린드롬
  for (let i = 0; i < n; i++) {
    dp[i][i] = true;
  }

  // 2. 부분 문자열 길이 len = 2, 3, ... n에 대해 검사
  for (let len = 2; len <= n; len++) {
    for (let i = 0; i <= n - len; i++) {
      const j = i + len - 1; // 부분 문자열 끝 인덱스

      if (s[i] === s[j]) {
        if (len === 2 || dp[i + 1][j - 1]) {
          dp[i][j] = true;
          if (len > maxLen) {
            start = i;
            maxLen = len;
          }
        }
      }
    }
  }

  return s.substring(start, start + maxLen);
}
```
