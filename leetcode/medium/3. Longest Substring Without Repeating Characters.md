> 풀이 날짜 : 2025.08.29  
> 문제 유형 : Hash Table, String, Sliding Window  
> 문제 제목 : 3. Longest Substring Without Repeating Characters  
> 문제 링크 : https://leetcode.com/problems/longest-substring-without-repeating-characters/description/

### Intuition

- 주어진 문자열 안에서 반복되지 않는 가장 긴 하위 문자열의 길이를 구하는 문제이다.

- 두 가지 문제 풀이 방식을 떠올려보았다.

  1. Brute Force: 부분 문자열을 문자열 자체로 관리하면서, 중복 문자가 나오면 잘라내는 방식

  2. Hash Table + Sliding Window: 중복 문자가 나타나면 왼쪽 포인터를 당겨서 윈도우를 줄이고, 현재 윈도우 안에 어떤 문자들이 있는지만 관리한다.

### Approach

#### 1. Brute Force

- s의 길이가 0 또는 1이면 s의 길이를 그대로 반환한다.
- 중복되지 않는 하위 문자열의 길이를 저장할 배열(lengths)과 하위 문자열을 저장할 변수(sub)를 선언한다.

- 문자열 s의 첫 번째 문자부터 마지막 문자까지 순회한다.

  - 현재 문자가 중복되는 문자라면 현재 sub의 길이를 lengths에 추가하고,
    중복된 문자 이후의 문자열을 자르고 뒤에 현재 문자를 붙여서 새로운 sub으로 저장한다.

  - 현재 문자가 중복되지 않는다면 현재 문자를 sub에 더하고,
    만약 마지막 문자라면 현재 sub의 길이를 lengths에 추가한다.

- lengths 배열 요소 중 최댓값을 반환한다.

#### 2. Hash Table + Sliding Window (Set)

- 현재 윈도우의 안의 문자들을 관리할 Set을 선언한다.

- right 포인터를 하나씩 늘려가면서 Set에 없는 문자를 넣는다.

- 중복 문자가 나오면 left 포인터를 움직여서 Set에서 그 문자를 제거할 때까지 오른쪽으로 이동한다.
  (\* 윈도우의 왼쪽을 줄여서 중복을 없애는 과정이다.)

- 중복 문자가 아니라면 Set에 추가한다.
  (\* 새로운 윈도우에 이 문자를 포함시킨다.)

- 이 과정을 반복하면서 현재 윈도우 크기(`right - left + 1`)와 지금까지의 최댓값(maxLen)을 비교하여 갱신한다.

- 흐름 예시

  ```
  s = a b c a b c b b
  Set = {}
  left = 0
  maxLen = 0

  (1)
  [ a ] b c a b c b b
  Set = {a}, left=0, right=0

  (2)
  [ a b ] c a b c b b
  Set = {a,b}, left=0, right=1

  (3)
  [ a b c ] a b c b b
  Set = {a,b,c}, left=0, right=2

  (4)
  a [ b c a ] b c b b
  Set = {a,b,c}, left=1, right=3

  (5)
  a b [ c a b ] c b b
  Set = {a,b,c}, left=2, right=4

  (6)
  a b c [ a b c ] b b
  Set = {a,b,c}, left=3, right=5

  (7)
  a b c a [ c b ] b
  Set = {c,b}, left=5, right=6

  (8)
  a b c a b c [ b ]
  Set = {b}, left=7, right=7

  최대 길이 = 3 ("abc")
  ```

### Complexity

- Time complexity:

  s의 길이를 n이라고 할 때,

  1. Brute Force: `O(n²)`

     - for 루프는 n만큼 돈다. for 루프 내부에서는 `sub.includes`, `sub.indexOf`, `sub.slice` 가 최악의 경우 O(n)이 된다. 따라서 전체 시간복잡도는 O(n²)이다.

  2. Hash Table + Sliding Window: `O(n)`
     - 각 문자는 포인터에 의해 최대 두 번 처리된다.

- Space complexity:

  1. Brute Force: `O(n)`

     - sub 문자열에는 최대 n개의 문자가 들어갈 수 있고, lengths 배열도 최대 n개의 길이가 저장될 수 있다. 따라서 전체 공간복잡도는 O(n)이다.

  2. Hash Table + Sliding Window: `O(1)`
     - 문제 조건에서 `s consists of English letters, digits, symbols and spaces.`라고 명시하고 있다. 중복 없이 최대 95개 문자가 들어갈 수 있고, 이는 s의 길이와 무관하게 일정하다고 볼 수 있다.

### Code(TS)

#### 1. Brute Force

```ts
function lengthOfLongestSubstring(s: string): number {
  if (s.length < 2) {
    return s.length;
  }

  const lengths = [];
  let sub = "";

  for (let i = 0; i < s.length; i++) {
    const ch = s[i];

    if (sub.includes(ch)) {
      lengths.push(sub.length);
      sub = sub.slice(sub.indexOf(ch) + 1) + ch;
    } else {
      sub += ch;

      if (i === s.length - 1) {
        lengths.push(sub.length);
      }
    }
  }

  return Math.max(...lengths);
}
```

#### 2. Hash Table + Sliding Window (Set)

```ts
function lengthOfLongestSubstring(s: string): number {
  let set = new Set<string>();
  let left = 0,
    maxLen = 0;

  for (let right = 0; right < s.length; right++) {
    while (set.has(s[right])) {
      set.delete(s[left]);
      left++;
    }
    set.add(s[right]);
    maxLen = Math.max(maxLen, right - left + 1);
  }

  return maxLen;
}
```
