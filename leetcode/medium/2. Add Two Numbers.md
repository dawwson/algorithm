> 풀이 날짜 : 2025.08.27  
> 문제 유형 : Linked List, Math, Recursion  
> 문제 제목 : 2. Add Two Numbers  
> 문제 링크 : https://leetcode.com/problems/add-two-numbers/description/

### Intuition

- 주어진 두 개의 단방향 연결리스트를 역순으로 읽은 숫자의 합을 다시 연결리스트로 반환해야 한다.
- 두 연결리스트를 순차적으로 조회해서 두 수의 합이 10을 넘는 경우 올림값을 저장해두고 다음 노드에 더하는 방식을 떠올렸다.
- 반복문으로 푸는 방법과 재귀로 푸는 방법이 있겠다.
  - 반복문
    - while 문으로 두 리스트를 순회하면서 합을 계산하고 올림값 처리
  - 재귀
    - 현재 자리 합 + 올림값을 계산하고, 다음 노드 처리를 재귀 호출
    - 코드가 간결해지기는 하지만 리스트 길이가 길면 stack overflow 위험이 있다.
      **(코드 스타일이나 방법의 차이이지, 효율 자체를 크게 올리기는 어렵다.)**

### Approach

#### Iteration

- 결과를 저장할 시작 노드(answer)를 선언한다.
  현재까지의 연결리스트를 저장할 dummy 노드 current에 answer를 저장한다.
  올림값을 저장할 변수 carry를 0으로 선언한다.
- l1, l2, carry 값이 존재하는 동안 반복한다.
  - 현재 자리 합(sum)을 시작할 때 carry 값을 넣는다.
    이전 자리에서 올라온 값이 반영된다.
  - l1이 아직 남아있다면 현재 자리 값을 더하고, 다음 노드로 이동한다.
    l2가 아직 남아있다면 현재 자리 값을 더하고, 다음 노드로 이동한다.
  - sum이 10 이상이면 carry가 발생하므로 업데이트 한다.
    현재 자리(sum % 10)를 새로운 노드로 만들어서 결과 리스트에 연결한다.
    current 포인터를 새로 만든 노드로 이동한다.
- answer의 다음 노드가 결과 리스트 첫 번째 노드이므로 answer.next를 반환한다.

#### Recursion

- 다음 노드와 carry가 없으면 null을 반환한다. (재귀 종료 조건)
- 현재 자리 합을 시작할 때 carry 값으로 초기화한다.
- l1, l2 노드가 존재하면 각각 현재 자리 값을 sum에 더한다.
- 현재 자리(sum % 10) 값을 저장하는 새로운 노드를 생성한다.
- 재귀 호출하여 다음 자리 합을 계산한다.
  - 매개변수로 다음 노드와 새로운 carry를 전달한다.
  - 재귀가 끝나면 node.next가 다음 자리 노드를 가리킨다.
- 현재 자리 노드를 반환한다.
  재귀 호출이 쌓이면서 전체 연결리스트가 반환된다.

### Complexity

- Time complexity: `O(max(m, n)`

  - l1, l2의 길이를 m, n이라고 가정
  - Iteration: `O(max(m, n)`
    - 한 번의 반복문으로 두 리스트를 끝까지 순회하므로 O(max(m, n)
  - Recursion: `O(max(m, n)`
    - 한 번의 재귀 호출마다 한 자리 계산하므로 O(max(m, n)

- Space complexity:
  - Iteration: `O(max(m, n)`
    - 새로운 결과 리스트를 만들기 위해 O(max(m, n)) 공간 사용
  - Recursion: `O(max(m, n)`
    - 새로운 결과 리스트를 만들기 위해 O(max(m, n)) 공간 사용
      거기다가 재귀 호출 스택도 각 자리마다 하나씩 쌓임

### Code(TS)

#### Iteration

```ts
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function addTwoNumbers(
  l1: ListNode | null,
  l2: ListNode | null
): ListNode | null {
  const answer = new ListNode();
  let current = answer;
  let carry = 0;

  while (l1 || l2 || carry) {
    let sum = carry;

    if (l1) {
      sum += l1.val;
      l1 = l1.next;
    }
    if (l2) {
      sum += l2.val;
      l2 = l2.next;
    }

    carry = Math.floor(sum / 10);
    current.next = new ListNode(sum % 10);
    current = current.next;
  }

  return answer.next;
}
```

#### Recursion

```ts
function addTwoNumbersRecursive(
  l1: ListNode | null,
  l2: ListNode | null,
  carry = 0
): ListNode | null {
  if (!l1 && !l2 && carry === 0) return null;

  let sum = carry;
  if (l1) sum += l1.val;
  if (l2) sum += l2.val;

  const node = new ListNode(sum % 10);

  node.next = addTwoNumbersRecursive(
    l1 ? l1.next : null,
    l2 ? l2.next : null,
    Math.floor(sum / 10)
  );

  return node;
}
```
