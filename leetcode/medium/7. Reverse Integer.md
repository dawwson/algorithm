> 풀이 날짜 : 2025.09.04  
> 문제 유형 : Math  
> 문제 제목 : 7. Reverse Integer  
> 문제 링크 : https://leetcode.com/problems/reverse-integer/description/

### Intuition

- 주어진 숫자를 거꾸로 뒤집은 숫자를 반환한다.

- 제약 조건

  - 결과값이 32비트 부호 있는 정수 범위(`-2^31 ~ 2^31 - 1`)를 넘어가면 0으로 반환한다.

  - 주어진 환경이 64비트 부호 있는 정수를 저장하지 않는다고 가정한다.

- 두 가지 방법이 있을 수 있다.

  - 수학적 방식: 10으로 나눈 나머지를 활용하는 방법

  - 문자열 변환: 문자열로 바꿔서 문자열 함수를 이용하는 방법

### Approach

#### 1. 수학적 방식

- `MAX_INT`: 32비트 정수의 최댓값
  `n`: x의 절댓값
  `result`: 최종적으로 뒤집힌 수를 저장할 변수. 0으로 초기화한다.

- n이 0이 될 때까지 반복한다.

  - `digit`: n의 마지막 자리 추출한 값

  - 마지막 자리를 제거한 값으로 n을 갱신한다.

  - 10을 곱하기 전에 오버플로우 여부를 검사한다.

    - `result > MAX_INT / 10` 이면 10을 곱했을 때 초과한다. (음수여도 마찬가지)

    - `result === MAX_INT / 10`이면서 마지막 digit이 `MAX_INT % 10`보다 크면 초과한다.

    - 범위를 벗어난다면 0을 반환한다.

- 최종적으로 뒤집힌 수가 원래 음수였는지 양수였는지에 따라 부호를 붙여서 반환한다.

#### 2. 문자열 변환

- 32비트 정수 범위를 상수로 정의한다.

- 입력값을 절댓값 -> 문자열 -> 배열 -> 배열 뒤집기 -> 문자열 합치기로 뒤집는다.

- 입력값 부호에 따라 부호를 붙여 숫자로 변환한다.

- 뒤집은 값이 32비트 정수 범위를 벗어나면 0을 반환한다.

- 범위 안이면 최종 뒤집힌 숫자를 반환한다.

### Complexity

- Time complexity:

  1. 수학적 방식: `O(1)`

     - 반복 횟수가 최대 10번이므로 O(1)로 봐도 무방하다.

  2. 문자열 변환: `O(1)`

- Space complexity: `O(1)`

  1. 수학적 방식: `O(1)`

  2. 문자열 변환: `O(1)`

### Code (TS)

#### 1. 수학적 방식

```ts
function reverse(x: number): number {
  const MAX_INT = 2 ** 31 - 1; // 2147483647

  let n = Math.abs(x);
  let result = 0;

  while (n !== 0) {
    const digit = n % 10;
    n = Math.floor(n / 10);

    // overflow check (10 곱하기 전에 확인)
    const isOverflow =
      result > Math.floor(MAX_INT / 10) ||
      (result === Math.floor(MAX_INT / 10) && digit > MAX_INT % 10);

    if (isOverflow) {
      return 0;
    }

    result = result * 10 + digit;
  }

  return x < 0 ? -result : +result;
}
```

<p align="center">
	<img src="https://velog.velcdn.com/images/pasteldenata27/post/74d278e0-7b83-4890-9d2f-117fcd8a9b28/image.png" width="800"/>
</p>


#### 2. 문자열 변환 (더 빠르다...)

```ts
function reverse(x: number): number {
  const MAX_INT = 2 ** 31 - 1;
  const MIN_INT = -(2 ** 31);

  const str = Math.abs(x).toString().split("").reverse().join("");
  const reversed = x < 0 ? -str : +str;

  if (reversed < MIN_INT || reversed > MAX_INT) {
    return 0;
  }

  return reversed;
}
```

<p align="center">
	<img src="https://velog.velcdn.com/images/pasteldenata27/post/8d7af6bf-28de-4d44-a890-d2fa85351616/image.png" width="800"/>
</p>
