> 풀이 날짜 : 2025.08.25  
> 문제 유형 : Array, Hash Table  
> 문제 제목 : Two Sum  
> 문제 링크 : https://leetcode.com/problems/two-sum/description

### Intuition

- 주어진 배열에서 합이 target과 같아지는 두 수의 인덱스를 구하는 문제이다.
- 두 가지 방법이 떠올랐다.
  1. (Brute Force) 중첩된 for문으로 배열 요소의 모든 조합을 구하기
  2. (Hash Table) 배열 안에서 `target - nums[i]`가 있는 위치를 찾기

### Approach

#### 1. Brute Force

- 모든 인덱스를 조회하기 위해 i는 0부터, j는 1부터 nums의 크기만큼 반복한다.
- i와 j가 같으면 다음 루프로 넘어간다.
- i번째 요소와 j번째 요소의 합이 target과 같으면 i, j를 배열로 반환한다.

#### 2. Hash Table

- 배열 요소의 값을 key, 인덱스를 value로 하는 Map을 선언한다.
- 배열의 모든 요소를 순회한다.
  - target에서 배열 요소를 뺀 값을 complement라고 할 때,
    complement가 Map에 있으면 현재 요소의 인덱스와 complement의 인덱스를 배열로 반환한다.
    complement가 Map에 없으면 현재 요소의 값과 인덱스를 Map에 추가한다.

### Complexity

- Time complexity:
  - Brute Force: `O(n²)`
  - Hash Table: `O(n)`
- Space complexity:

  - Brute Force: `O(1)`
  - Hash Table: `O(n)`

  👉 주어진 배열의 크기가 N이라고 할 때,
  Brute Force 방식은 중첩된 for문을 사용하므로 시간복잡도는 O(n²), 추가적인 자료구조를 쓰지 않으므로 공간복잡도는 O(1)이다.
  Hash Table 방식은 한 번의 for문을 사용하므로 시간복잡도는 O(n), 해시테이블에 최대 n개의 요소를 저장하므로 공간복잡도는 O(n)이다.
  n의 크기가 작다면 Brute Force 방식도 잘 동작하지만, n의 크기가 커진다면 Hash Table 방식이 효율적이다. `✔ trade-off`

### Code (TS)

#### Brute Force

```ts
function twoSum(nums: number[], target: number): number[] {
  for (let i = 0; i < nums.length; i++) {
    for (let j = 1; j < nums.length; j++) {
      if (i === j) {
        continue;
      }
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }

  return [];
}
```

#### Hash Table

```ts
function twoSum(nums: number[], target: number): number[] {
  const ht = new Map();

  for (let i = 0; i < nums.length; i++) {
    const num = nums[i];
    const complement = target - num;

    if (ht.has(complement)) {
      return [ht.get(complement), i];
    }
    ht.set(num, i);
  }

  return [];
}
```
