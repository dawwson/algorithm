> 풀이 날짜 : 2026.01.04  
> 문제 유형 : 해시 테이블  
> 문제 제목 : 10546. 배부른 마라토너  
> 문제 링크 : https://www.acmicpc.net/problem/10546

<br>

### Intuition

---

- 문제의 핵심 요구사항

  - 참가자 `N`명 중 완주자는 `N-1`명
  - 완주하지 못한 단 한 명의 이름을 찾아야 한다.
  - 이름은 문자열이며 동명이인이 존재할 수 있다.

- 제약 조건 분석

  - `1 <= N <= 10⁵`
  - 단순 이중 루프로 문자열 비교 및 탐색은 시간이 초과될 수 있다.

- 문제풀이 방향

  - 문자열 기반의 빠른 조회/삽입/갱신 및 동명이인에 대한 처리가 필요하므로 `Map`이 적합하다고 판단했다.
  - 이름을 `Key`로 하고, 인원 수를 `Value`로 관리한다.
  - 참가자는 확인할 때는 인원 수를 `+1` 하고, 완주자를 확인할 때는 인원 수를 `-1`을 한다.
  - 최종적으로 값이 `0`이 아닌 `Key`가 정답이다.

<br>

### Approach

---

- 알고리즘

  - 해시 테이블 기반 빈도 카운팅 방식

- 자료구조

  - `HashMap<String, Integer>`
  - 문자열을 `Key`로 사용 가능하고 평균적으로 삽입/조회/갱신이 `O(1)`이다.
  - `Value`를 통해 동명이인 처리가 가능하다.

- 처리 단계

  - 참가자를 저장할 `HashMap`을 선언한다. (`Key`: `name`, `Value`: `count`)
  - 참가자 `N`명을 읽으며 이름이 이미 존재하면 `count + 1`을 하고, 없으면 새로 추가한다.
  - 완주자 `N-1`명을 읽으며 해당 이름의 `count`를 `-1`을 한다.
  - `HashMap`을 순회하며 `count`가 `0`이 아닌 이름을 출력한다.

<br>

### Complexity

---

- Time complexity: `O(N)`

  - 참가자 입력 처리에 `O(N)`, 완주자 입력 처리에 `O(N)`, Map 순회에 `O(N)`
  - 종합적으로 `O(N)`이라고 볼 수 있다.

- Space complexity: `O(N)`
  - 최악의 경우 동명이인이 없다고 할 때, 최대 `N`개의 `{Key, Value}`를 저장하기 위한 `Map`을 사용했다.

<br>

### Code (Java)

---

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    public static void main(String[] args) throws Exception {

        // 입출력 스트림 생성
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());

        // 참가자 저장 { 이름 : 인원수 }
        Map<String, Integer> countMap = new HashMap<>();

        for (int i = 0; i < N; i++) {
            String name = br.readLine();

            // 동명이인이면 +1, 없으면 추가
            countMap.put(name, countMap.getOrDefault(name, 0) + 1);
        }

        // 완주자 제거
        for (int i = 0; i < N - 1; i++) {
            String name = br.readLine();

            countMap.put(name, countMap.get(name) - 1);
        }

        // count가 0이 아닌 사람 찾기
        for (String name : countMap.keySet()) {
            if (countMap.get(name) != 0) {
                System.out.print(name);
            }
        }
    }
}
```
