> 풀이 날짜 : 2026.01.29  
> 문제 유형 : 그래프 탐색 (BFS/DFS)  
> 문제 제목 : 1012. 유기농 배추  
> 문제 링크 : https://www.acmicpc.net/problem/1012

<br>

### Intuition

---

<!--
- 제약 조건
- 단순 접근의 한계
- 필요한 성질 (시간/공간/구조)
- 선택한 해법
-->

- 제약 조건: 가로/세로 최대 `50`, 배추 개수 최대 `2,500`개로 비교적 크기가 작다.

- 핵심 원리: 상하좌우로 인접한 배추들은 하나의 '지렁이'로 보호받을 수 있다. 이는 그래프 이론에서 연결된 컴포넌트(Connected Component)의 개수를 찾는 문제와 동일하다.

- 선택한 해법: 2차원 그래프를 전체 탐색하며, 방문하지 않은 배추를 발견할 때마다 BFS를 수행하여 인접한 모든 배추를 방문 처리하고 지렁이 수를 `1`씩 증가시킨다.

<br>

### Approach

---

<!--
- 실제로 채택한 알고리즘
- 자료구조 선택 이유
- 단계별 처리 방식
-->

- 알고리즘: `BFS` (너비 우선 탐색)

- 자료구조:
  - `int[][]` 배열로 맵을 표현하고, `boolean[][]`으로 방문 여부를 관리한다.
  - `Queue<int[]>`를 사용하여 `BFS`의 큐를 구현한다.

- 단계별 처리:
  - 이중 반복문으로 전체 맵을 순회한다.
  - `graph[x][y] == 1`이고 `visited[x][y] = false`인 지점(새로운 군집)을 찾으면 `BFS` 호출한다.
  - `BFS` 내부에서 큐에 넣는 즉시 방문 처리를 하여 중복 방문을 차단한다.
  - 한 번의 `BFS`가 끝나면 지렁이 수(`count`)를 증가시킨다.

<br>

### Complexity

---

- Time complexity: `O(T * (M * N))`
  - 테스크 케이스의 개수를 `T`, 가로 길이를 `M`, 세로 길이를 `N`이라고 할 때, 각 테스트 케이스당 이차원 배열의 모든 칸을 한 번씩 확인하며, 배추가 있는 칸도 최대 한 번씩만 큐에 들어가므로 이차원 배열 크기에 비례한다.
  - `T`의 범위는 문제에 드러나있지 않아 상수로 생각하지 않고 시간복잡도에 포함한다.

- Space complexity: `O(M * N)`
  - 격자 정보를 담는 배열과 방문 체크 배열의 크기에 비례한다.

<br>

### Code (Java)

---

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {

    static int[][] graph;       // 인접 리스트
    static boolean[][] visited; // 방문 여부 체크 리스트

    public static void main(String[] args) throws Exception {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        StringBuilder sb = new StringBuilder();

        int tc = Integer.parseInt(st.nextToken()); // 테스트 케이스 개수

        for (int i = 0; i < tc; i++) {
            // 지렁이 개수 (tc 마다 초기화)
            int count = 0;

            st = new StringTokenizer(br.readLine());

            int M = Integer.parseInt(st.nextToken()); // 가로 길이
            int N = Integer.parseInt(st.nextToken()); // 세로 길이
            int K = Integer.parseInt(st.nextToken()); // 배추 개수

            graph = new int[M][N];       // 0으로 초기화됨
            visited = new boolean[M][N]; // false로 초기화됨

            // graph 생성
            for (int j = 0; j < K; j++) {
                st = new StringTokenizer(br.readLine());

                // 배추 좌표
                int x = Integer.parseInt(st.nextToken());
                int y = Integer.parseInt(st.nextToken());

                graph[x][y] = 1;
            }

            for (int x = 0; x < M; x++) {
                for (int y = 0; y < N; y++) {
                    // 배추가 존재하고, 방문하지 않았다면 탐색 시작
                    if (graph[x][y] == 1 && !visited[x][y]) {
                        bfs(x, y);
                        count += 1;
                    }
                }
            }

            sb.append(count + "\n");
        }

        System.out.println(sb);
    }

    public static void bfs(int startX, int startY) {
        Queue<int[]> q = new LinkedList<>();

        // 시작점 - 큐에 넣고 방문 처리
        q.add(new int[]{startX, startY});
        visited[startX][startY] = true;

        // 인접한 배추가 있을 때
        while (!q.isEmpty()) {
            // 하나 뽑음
            int[] position = q.poll();
            int currX = position[0];
            int currY = position[1];

            // 인접 여부 확인하여 존재하면 큐에 넣고 방문 처리 (메모리 초과 방지)
            // 위로 이동
            if (exist(currX-1, currY)) {
                q.add(new int[]{currX-1, currY});
                visited[currX-1][currY] = true;
            }
            // 아래로 이동
            if (exist(currX+1, currY)) {
                q.add(new int[]{currX+1, currY});
                visited[currX+1][currY] = true;
            }
            // 왼쪽으로 이동
            if (exist(currX, currY-1)) {
                q.add(new int[]{currX, currY-1});
                visited[currX][currY-1] = true;
            }
            // 오른쪽으로 이동
            if (exist(currX, currY+1)) {
                q.add(new int[]{currX, currY+1});
                visited[currX][currY+1] = true;
            }
        }
    }

    // 배추가 있는지 확인
    public static boolean exist(int x, int y) {
        // 좌표를 벗어났을 때
        boolean outOfGraph = x < 0 || x >= graph.length || y < 0 || y >= graph[0].length;

        if (outOfGraph) {
            return false;
        }

        // 배추가 없을 때
        if (graph[x][y] == 0) {
            return false;
        }

        // 이미 방문했을 때
        if (visited[x][y]) {
            return false;
        }

        return true;
    }
}
```
