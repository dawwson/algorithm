> 풀이 날짜 : 2026.01.05  
> 문제 유형 : Stack  
> 문제 제목 : 스택  
> 문제 링크 : https://www.acmicpc.net/problem/10828

<br>

### Intuition

---

- 문제의 핵심 요구사항

  - 스택의 기본 연산인 `push`, `pop`, `top`, `size`, `empty`를 그대로 구현하는 문제이다.

- 제약 조건

  - 명령어 개수 n이 최대 10,000으로 크기 때문에, 각 명령을 빠르게 처리할 수 있어야 한다.
  - 모든 명령은 "이전 상태"에 의존하므로 한 번에 처리할 수 없고, 입력 순서대로 즉시 처리해야 한다.

- `Java`의 `Stack` 클래스는 `Vector`를 상속한 레거시 구조이다.

  - 모든 메서드가 `synchronized` 되어 있어 단일 스레드 환경(알고리즘 문제)에서는 불필요한 성능 오버헤드가 발생한다.
  - 또한 `Vector`의 모든 메서드를 그대로 사용 가능해 스택의 `LIFO` 추상화가 깨질 수 있다.
  - 따라서 다른 자료구조를 통해 스택을 직접 구현하는 것이 적절하다고 판단했다.

- `ArrayList`

  - 스택의 `top`은 항상 마지막에 들어온 원소이므로, `ArrayList`의 끝 인덱스를 스택의 `top`으로 사용하면 자연스럽게 `LIFO` 구조를 만들 수 있다.
  - 또한 `add()`와 `remove(size - 1)`, `get(size - 1)` 연산은 평균적으로 `O(1)`이므로 문제의 제약 범위 내에서 충분히 효율적이다.

- `Deque`

  - 스택은 개념적으로 한쪽 끝에서만 삽입/삭제가 일어나는 자료구조이므로, 양쪽 끝 삽입/삭제를 지원하는 `Deque`가 스택의 추상화에 더 잘 맞는다.
  - `Deque`를 스택처럼 사용할 경우 다음과 같이 명확하게 `LIFO` 의미가 드러난다.
    - `push` → `addLast`
    - `pop` → `removeLast`
    - `top` → `peekLast`
  - `ArrayDeque`는 내부적으로 배열 기반이며, 양 끝 연산이 모두 `O(1)`로 보장되어 스택 구현에 적합하다.
  - 또한 `Stack` 클래스와 달리 불필요한 동기화 비용이 없고, `Java` 공식 문서에서도 스택 용도로 `Deque` 사용을 권장한다. [[참고]](https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html)
  - 따라서 의미적 명확성과 표준적인 구현 측면에서는 `Deque`가 더 적절한 선택이 될 수 있다.

<br>

### Approach

---

1️⃣ **ArrayList**

- 연산별 처리 방식

  - `push`: `add(value)`
    - 리스트 끝에 원소 추가
  - `pop`: `remove(size - 1)`
    - 리스트 끝 원소 제거 및 반환
    - 리스트가 비어 있으면 `-1` 출력
  - `top`: `get(size - 1)`
    - 리스트 끝 원소 조회
    - 리스트가 비어 있으면 `-1` 출력
  - `size`: `size()` 반환
  - `empty`: `size == 0` 여부로 판단

- 각 명령은 `O(1)`에 처리 가능하므로 입력 순서대로 바로 실행한다.

<br>

2️⃣ **Deque**

- 연산별 처리 방식

  - `push`: `addLast(value)`
    - 덱의 뒤쪽에 원소 추가
  - `pop`: `removeLast()`
    - 덱의 뒤쪽 원소 제거 및 반환
    - 덱이 비어 있으면 `-1` 출력
  - `top`: `peekLast()`
    - 덱의 뒤쪽 원소 조회
    - 덱이 비어 있으면 `-1` 출력
  - `size`: `size()` 반환
  - `empty`: `isEmpty()` 여부로 판단

- 스택의 top을 덱의 **뒤쪽(last)**으로 통일함으로써 모든 연산을 한쪽 끝에서만 수행하는 `LIFO` 구조를 유지한다.

- `ArrayDeque`는 배열 기반 덱으로, 양 끝 삽입/삭제 연산이 모두 `O(1)`에 처리되므로 각 명령을 입력 순서대로 바로 실행할 수 있다.

<br>

### Complexity

---

1️⃣ **ArrayList**

- Time complexity: `O(n)`

  - 총 명령어 개수가 `n`일 때, 각 명령(`push`, `pop`, `top`, `size`, `empty`)은 모두 평균적으로 `O(1)`에 처리된다.
  - 따라서 전체 시간복잡도는 `O(1) × n = O(n)`이다.

- Space complexity: `O(n)`

  - 스택에 최악의 경우 `n`개의 원소가 저장될 수 있다.
  - 추가로 사용하는 변수들은 상수 공간이므로 전체 공간복잡도는 `O(n)`이다.

<br>

2️⃣ **Deque**

- Time complexity: `O(n)`

  - `addLast`, `removeLast`, `peekLast`, `size`, `isEmpty` 연산은 모두 `O(1)`에 수행된다.
  - 명령어를 `n`번 처리하므로 전체 시간복잡도는 `O(n)`이다.

- Space complexity: `O(n)`

  - `ArrayDeque` 역시 스택에 최대 `n`개의 원소를 저장할 수 있다.
  - 추가적인 보조 자료구조를 사용하지 않으므로 공간복잡도는 `O(n)`이다.

<br>

### Code (Java)

---

1️⃣ **ArrayList**

```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {

        Scanner sc = new Scanner(System.in);

        // 명령어 개수
        int n = sc.nextInt();

        // 스택 준비
        ArrayList<Integer> stack = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            String command = sc.next();

            switch (command) {
                case "push":
                    stack.add(sc.nextInt());
                    break;
                case "pop":
                    if (stack.isEmpty()) {
                        print(-1);
                    } else {
                        int poppedValue = stack.remove(stack.size() - 1);
                        print(poppedValue);
                    }
                    break;
                case "size":
                    print(stack.size());
                    break;
                case "empty":
                    print(stack.size() == 0 ? 1 : 0);
                    break;
                case "top":
                    if (stack.isEmpty()) {
                        print(-1);
                    } else {
                        print(stack.get(stack.size() - 1));
                    }
                    break;
            }
        }
    }

    private static void print(int value) {
            System.out.println(value);
    }
}
```

<br>

2️⃣ **Deque**

```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();

        int n = Integer.parseInt(br.readLine());

        Deque<Integer> stack = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            String command = st.nextToken();

            switch (command) {
                case "push":
                    stack.addLast(Integer.parseInt(st.nextToken()));
                    break;

                case "pop":
                    if (stack.isEmpty()) {
                        sb.append(-1).append("\n");
                    } else {
                        sb.append(stack.removeLast()).append("\n");
                    }
                    break;

                case "size":
                    sb.append(stack.size()).append("\n");
                    break;

                case "empty":
                    sb.append(stack.isEmpty() ? 1 : 0).append("\n");
                    break;

                case "top":
                    if (stack.isEmpty()) {
                        sb.append(-1).append("\n");
                    } else {
                        sb.append(stack.peekLast()).append("\n");
                    }
                    break;
            }
        }

        System.out.print(sb);
    }
}
```
