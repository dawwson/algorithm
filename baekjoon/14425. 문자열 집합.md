> 풀이 날짜 : 2026.01.02  
> 문제 유형 : 해시 테이블  
> 문제 제목 : 14425. 문자열 집합  
> 문제 링크 : https://www.acmicpc.net/problem/14425

<br>

### Intuition

---

- 문제의 핵심 요구사항은

  - 문자열 `N`개로 이루어진 집합 `S`와, `M`개의 문자열이 주어질 때
  - 각 문자열이 집합 `S`에 포함되어 있는지 확인한다.
  - 단순 출력이 아니라 포함된 문자열의 개수를 구하는 문제이다.

- 입력 크기는

  - `N`, `M` <= `10,000`
  - 최악의 경우 문자열 비교를 선형 탐색으로 하면 `O(N * M)`으로 시간 초과될 수 있다.

- 조회 성능이 더 높은 자료구조가 필요하다.
  - 이 문제에서 필요한 연산은 존재 여부 확인하는 것 하나 뿐이다.
  - 값 자체가 `Key` 역할을 하므로 `Map` 구조는 오버스펙이고, `Set`이 문제 요구에 정확히 부합한다.

<br>

### Approach

---

- 알고리즘

  - 해시 테이블 기반 조회

- 자료구조

  - `HashSet<String>`
  - (집합 `S`에 중복은 없다는 조건이 있긴 하지만) 중복이 자동으로 제거되고 존재 여부를 평균 `O(1)`로 빠르게 검사할 수 있다.

- 처리 단계

  - `N`개의 문자열을 `Set`에 저장한다.
  - 다음 `M`개의 문자열을 읽으면서 Set에 존재하는지 여부를 검사한다.
    - 존재한다면 `count`를 `1`만큼 증가시킨다.
  - `count`를 출력한다.

<br>

### Complexity

---

- Time complexity: `O(N + M)`

  - `N`개의 문자열 조회 및 `HashSet` 저장에 `O(N)`, `M`개의 문자열 조회에 `O(M)`

- Space complexity: `O(N)`

  - `N`개의 문자열 저장을 위한 `HashSet` 사용

<br>

### Code (Java)

---

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    public static void main(String[] args) throws Exception {

        // 입출력 스트림 생성
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        // 집합 S의 문자열 개수
        int N = Integer.parseInt(st.nextToken());
        // 검사해야 하는 문자열 개수
        int M = Integer.parseInt(st.nextToken());

        // N개의 문자열 읽어서 집합 S에 저장
        Set<String> S = new HashSet<>();

        for (int i = 0; i < N; i++) {
            S.add(br.readLine());
        }

        // M개의 문자열 읽으면서 집합 S에 포함되어 있는지 확인
        int count = 0;

        for (int i = 0; i < M; i++) {
            String str = br.readLine();

            if (S.contains(str)) {
                count += 1;
            }
        }

        // 출력
        System.out.print(count);
    }
}
```
