> 풀이 날짜 : 2026.01.02  
> 문제 유형 : 해시 테이블  
> 문제 제목 : 7785. 회사에 있는 사람  
> 문제 링크 : https://www.acmicpc.net/problem/7785

<br>

### Intuition

---

- 문제의 핵심 요구사항

  - 직원의 출입 기록(enter / leave)이 주어진다.
  - 모든 기록을 처리한 후 현재 회사에 남아 있는 직원의 이름을 사전 역순(내림차순)으로 출력해야 한다.

- 출입 기록 수 `2 ≤ n ≤ 10⁶`
  - 각 기록마다 사람 이름을 추가하거나 제거해야 한다.
  - 최종 출력 시 정렬된 결과가 필요하다.
  - 따라서 삽입/삭제가 잦고, 중복이 없으며, 정렬 조건이 있는 `TreeSet` 자료구조가 적합하다고 판단했다.

<br>

### Approach

---

- 알고리즘

  - 해시 테이블 기반 삽입/삭제/조회

- 자료구조

  - `TreeSet<String>`
  - (문제에 동명이인이 없다는 조건이 있지만) 중복된 이름을 제거하고 직원 이름을 삽입/삭제/조회에 `Set`이 적합하다.
  - 문제에서 사전 역순 출력이 요구되는데, `TreeSet`은 항상 정렬된 상태로 유지된다. `Collections.reverseOrder()`로 데이터를 삽입/삭제할 때마다 내림차순 정렬을 즉시 적용할 수 있다.

- 단계별 처리 방식

  - `n`개의 출입 기록을 읽어서 `TreeSet`에 삽입 또는 삭제한다.
    - 정렬 기준을 내림차순으로 지정한다.
    - 출입 기록이 `enter`면 `TreeSet`에 삽입한다.
    - 출입 기록이 `leave`면 `TreeSet`에서 삭제한다.
  - `TreeSet`의 모든 요소를 출력한다.

<br>

### Complexity

---

- Time complexity: `O(n log n)`

  - `TreeSet`은 내부적으로 `Red-Black Tree` 기반의 균형 이진 탐색 트리로 구현되어 있어, 최악의 경우에도 트리의 높이가 `O(log n)`으로 유지된다. [[참고]](https://medium.com/@may1998/hashset-treeset%EC%9D%98-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-b583a9bb13df)
  - `add`, `remove` 연산은 삽입/삭제 위치를 찾고 트리의 균형을 유지하는 과정이 필요하므로 트리 높이에 비례하여 `O(log n)`의 시간복잡도를 가진다.
  - 출입 기록이 총 `n`개이고, 각 기록마다 `add` 또는 `remove` 연산이 한 번씩 수행되므로 전체 시간 복잡도는 `O(n log n)`이다.
  - 이는 `TreeSet`이 정렬을 마지막에 한 번 수행하는 방식이 아니라, 각 연산마다 정렬된 트리 구조를 유지하며 적절한 위치에 삽입/삭제하기 때문이다.

- Space complexity: `O(n)`

  - 회사에 남아있는 사람은 최대 `n`명으로, `n`개의 문자열 저장을 위한 `TreeSet`을 추가적으로 사용했다.

<br>

### Code (Java)

---

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    public static void main(String[] args) throws Exception {

        // 입출력 스트림 생성
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();

        // 첫 줄 읽기
        int n = Integer.parseInt(br.readLine());

        // 출입 기록을 읽어서 Set에 저장
        Set<String> set = new TreeSet<>(Collections.reverseOrder());

        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());

            String name = st.nextToken();
            String log = st.nextToken();

            if (log.equals("enter")) {
                set.add(name);
            } else {
                set.remove(name);
            }
        }

        for (String name : set) {
            sb.append(name + "\n");
        }

        System.out.print(sb);
    }
}
```
