> í’€ì´ ë‚ ì§œ : 2025.12.30  
> ë¬¸ì œ ìœ í˜• : í•´ì‹œ í…Œì´ë¸”, ì´ì§„ íƒìƒ‰  
> ë¬¸ì œ ì œëª© : ìˆ«ì ì¹´ë“œ  
> ë¬¸ì œ ë§í¬ : https://www.acmicpc.net/problem/10815

<br>

### Intuition

---

- ì´ ë¬¸ì œì˜ í•µì‹¬ ìš”êµ¬ì‚¬í•­ì€ ê° ìˆ«ìê°€ ê°€ì§€ê³  ìˆëŠ” ì¹´ë“œì— ì¡´ì¬í•˜ëŠ”ì§€ ì—¬ë¶€ë§Œ íŒë‹¨í•˜ëŠ” ê²ƒì´ë‹¤.

- ê°€ì§€ê³  ìˆëŠ” ì¹´ë“œì˜ ê°œìˆ˜ì™€ ê²€ì¦í•˜ëŠ” ì¹´ë“œì˜ ê°œìˆ˜ëŠ” ëª¨ë‘ ìµœëŒ€ 500,000ê°œë¡œ, ì¤‘ì²© ë°˜ë³µë¬¸ì„ ì‚¬ìš©í•œë‹¤ë©´ `O(n*m)`ìœ¼ë¡œ ì‹œê°„ ì´ˆê³¼ ë  ìˆ˜ ìˆë‹¤.

- ë”°ë¼ì„œ íƒìƒ‰ì— íŠ¹í™”ëœ ìë£Œêµ¬ì¡°(í•´ì‹œ í…Œì´ë¸”) ë˜ëŠ” ì´ì§„ íƒìƒ‰ ë°©ë²•ì´ ë– ì˜¬ëë‹¤.

  - í•´ì‹œ í…Œì´ë¸” : í‚¤-ê°’ ìŒì˜ êµ¬ì¡°ëŠ” í•„ìš” ì—†ìœ¼ë¯€ë¡œ `Map` ë³´ë‹¤ëŠ” `Set`ì´ ì ì ˆí•˜ë‹¤.
  - ì´ì§„ íƒìƒ‰ : í•œ ë²ˆì˜ ì •ë ¬ ì´í›„ ê° ì¹´ë“œ ê²€ì¦ì„ `O(log n)`ì˜ ì‹œê°„ë³µì¡ë„ë¡œ ë¹ ë¥´ê²Œ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.

<br>

### Approach

---

1ï¸âƒ£ **í•´ì‹œ í…Œì´ë¸”**

- `HashSet.contains()`ëŠ” í‰ê·  `O(1)`ì´ë¯€ë¡œ ì¡´ì¬ ì—¬ë¶€ë§Œ íŒë‹¨í•˜ê¸°ì—ëŠ” `HashSet`ì´ ìµœì ì´ë¼ê³  íŒë‹¨í–ˆë‹¤.

- ì¹´ë“œë¥¼ `HashSet`ì— ì €ì¥í•˜ê³ , ê° ì§ˆì˜ ìˆ«ìì— ëŒ€í•´ ì¡´ì¬í•˜ë©´ `1`, ì—†ìœ¼ë©´ `0`ì„ ì¶œë ¥í•œë‹¤.

<br>

2ï¸âƒ£ **ì´ì§„ íƒìƒ‰**

- ìƒê·¼ì´ì˜ ì¹´ë“œ ë°°ì—´ì„ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•œë‹¤.

- ê° ê²€ì¦í•  ìˆ«ìì— ëŒ€í•´

  - ì´ì§„ íƒìƒ‰ ìˆ˜í–‰
  - ì°¾ìœ¼ë©´ `1`, ì—†ìœ¼ë©´ `0`ì„ ì¶œë ¥í•œë‹¤.

<br>

### Complexity

---

1ï¸âƒ£ **í•´ì‹œ ê¸°ë°˜ íƒìƒ‰**

- Time complexity: `O(n + m)`

  - ì¹´ë“œ ì…ë ¥ `n`ê°œë¥¼ `Set`ì— ì €ì¥í•˜ë©´ `O(n)`
  - ì§ˆì˜ mê°œë¥¼ ê°ê° `O(1)`ë¡œ íƒìƒ‰

- Space complexity: `O(n)`

  - HashSetì˜ í¬ê¸°ë§Œí¼ ì¶”ê°€ ê³µê°„ì´ í•„ìš”í•˜ë‹¤.

<br>

2ï¸âƒ£ **ì •ë ¬ & ì´ì§„ íƒìƒ‰**

- Time complexity: `O(n log n + m log n)`

  - `Java`ì˜ `Array.sort()`ëŠ” `DualPivotQuicksort`ë¡œ í‰ê· ì ìœ¼ë¡œ `O(n log n)`, ìµœì•…ì˜ ê²½ìš° `O(nÂ²)` í‰ê°€ëœë‹¤. ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œì—ì„œ ì¼ë¶€ëŸ¬ í‰ê· ì´ ê¹¨ì§€ëŠ” ì…ë ¥ê°’ì„ ë„£ì§€ ì•ŠëŠ”ë‹¤ê³  ê°€ì •í•˜ê³  `O(n log n)`ìœ¼ë¡œ ê°„ì£¼í•œë‹¤.
  - ì¹´ë“œ ê²€ì¦í•  ë•Œë§ˆë‹¤ ì´ì§„ íƒìƒ‰í•˜ë©´ `m * O(log n)`
  - ì¢…í•©ì ìœ¼ë¡œ í‰ê°€í•˜ë©´ `O(n log n) + O(m log n) = O(n log n + m log m)`ì´ë‹¤.

- Space complexity: `O(n)`

  - ì¹´ë“œ ë°°ì—´ ì €ì¥

<br>

### Code (Java)

---

1ï¸âƒ£ **í•´ì‹œ ê¸°ë°˜ íƒìƒ‰**

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.util.HashSet;
import java.util.Set;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();

        int n = Integer.parseInt(br.readLine());
        Set<Integer> cards = new HashSet<>();

        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            cards.add(Integer.parseInt(st.nextToken()));
        }

        int m = Integer.parseInt(br.readLine());
        st = new StringTokenizer(br.readLine());

        for (int i = 0; i < m; i++) {
            int target = Integer.parseInt(st.nextToken());
            sb.append(cards.contains(target) ? "1 " : "0 ");
        }

        System.out.println(sb.toString().trim());
    }
}
```

<br>

2ï¸âƒ£ **ì •ë ¬ & ì´ì§„ íƒìƒ‰**

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.util.Arrays;

public class Main {

    static boolean binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] == target) {
                return true;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return false;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();

        int n = Integer.parseInt(br.readLine());
        int[] cards = new int[n];

        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            cards[i] = Integer.parseInt(st.nextToken());
        }

        // ì •ë ¬
        Arrays.sort(cards);

        int m = Integer.parseInt(br.readLine());
        st = new StringTokenizer(br.readLine());

        for (int i = 0; i < m; i++) {
            int target = Integer.parseInt(st.nextToken());
            sb.append(binarySearch(cards, target) ? "1 " : "0 ");
        }

        System.out.println(sb.toString().trim());
    }
}
```

<br>

3ï¸âƒ£ ì¤‘ì²© ë°˜ë³µë¬¸ (ì‹œê°„ ì´ˆê³¼ ğŸ”¥)

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int[] cards = new int[n];

        for (int i = 0; i < n; i++) {
            cards[i] = sc.nextInt();
        }

        int m = sc.nextInt();
        int[] cards2 = new int[m];

        for (int i = 0; i < m; i++) {
            cards2[i] = sc.nextInt();
        }

        for (int i = 0; i < m; i++) {
            boolean exist = false;

            for (int j = 0; j < n; j++) {
                if (cards2[i] == cards[j]) {
                    System.out.print(1 + " ");
                    break;
                } else if (j == n - 1) {
                    System.out.print(0 + " ");
                }
            }
        }
    }
}
```
