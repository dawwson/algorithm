> 풀이 날짜 : 2026.01.03  
> 문제 유형 : 해시 테이블  
> 문제 제목 : 1620. 나는야 포켓몬 마스터 이다솜  
> 문제 링크 : https://www.acmicpc.net/problem/1620

<br>

### Intuition

---

- 문제의 핵심 요구사항은

  - 입력이 번호(Integer) 또는 이름(String)으로 주어질 때
  - 해당 포켓몬 정보를 빠르게 조회하는 것이다.

- 포켓몬 개수(N)와 문제 개수(M)는 각각 최대 `100,000`으로,

  - 문제마다 선형 탐색을 하면 `O(N * M)`이 되어 시간 초과된다.
  - 따라서 각 문제를 상수 시간에 처리할 수 있는 자료구조가 필요하다고 판단했다.

- [번호 ➡️ 이름], [이름 ➡️ 번호] 양방향 조회가 모두 필요하므로, 단일 자료구조만으로는 요구사항을 충족하기 어렵다.

  - 처음에 해시 테이블 기반의 `Map`을 떠올렸다.
  - `Map`은 `Key ➡️ Value` 조회는 평균 `O(1)`로 빠르지만,
  - `Value`를 기준으로 `Key`를 찾는 연산은 내부적으로 인덱싱되지 않아 전체 순회가 필요하므로 `O(N)`이 된다.

- 입력이 숫자일 수도 있고 문자열일 수도 있기 때문에

  - [이름 ➡️ 번호] 조회는 `Map<String, Integer>`
  - [번호 ➡️ 이름] 조회는 인덱스 접근이 가능한 `Array`
  - 두 자료구조를 함께 사용해 **양방향 매핑 구조**를 구성하는 것이 가장 적절하다고 판단했다.

<br>

### Approach

---

- 알고리즘

  - 해시 테이블 기반 양방향 매핑

- 자료구조

  - 이름 ➡️ 번호 : `HashMap` (문자열 키 기반 탐색)
  - 번호 ➡️ 이름 : `Array` (인덱스 접근)

- 처리 단계

  - 포켓몬 이름을 Map에 저장한다. (이름 ➡️ 번호)
  - 번호에 해당하는 배열 인덱스 요소에 이름을 저장한다.
  - 입력의 첫 글자가 숫자인지 판별한다.
    - 숫자면 배열에서 조회한다.
    - 문자면 Map에서 조회한다.

<br>

### Complexity

---

- Time complexity: `O(N + M)`

  - 포켓몬 정보 저장에 `O(N)`, 문제 처리에 `O(M)`이다.
  - Map 조회 및 배열 접근은 평균 `O(1)`이다.

- Space complexity: `O(N)`

  - `Map`에 `N`개, 배열에 `N`개 저장하므로, 종합적으로 `O(N)`이다.

<br>

### Code (Java)

---

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    public static void main(String[] args) throws Exception {

        // 입출력 스트림 생성
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        StringBuilder sb = new StringBuilder();

        // 포켓몬 개수
        int N = Integer.parseInt(st.nextToken());
        // 맞춰야 하는 문제 개수
        int M = Integer.parseInt(st.nextToken());

        // 양방향 매핑 (Map, Array)
        Map<String, Integer> nameToNum = new HashMap<>();
        String[] numToName = new String[N + 1];

        for (int i = 1; i <= N; i++) {
            String name = br.readLine();

            nameToNum.put(name, i);
            numToName[i] = name;
        }

        // Map, Array 조회
        for (int i = 0; i < M; i++) {
            String input = br.readLine();
            boolean isDigit = Character.isDigit(input.charAt(0));

            if (isDigit) {
                int num = Integer.parseInt(input);
                sb.append(numToName[num] + "\n");
            } else {
                sb.append(nameToNum.get(input) + "\n");
            }
        }

        System.out.print(sb);
    }
}
```
