> 풀이 날짜 : 2026.01.30  
> 문제 유형 : 그래프 탐색 (BFS)  
> 문제 제목 : 2178. 미로 탐색  
> 문제 링크 : https://www.acmicpc.net/problem/2178

<br>

### Intuition

---

<!--
- 제약 조건
- 단순 접근의 한계
- 필요한 성질 (시간/공간/구조)
- 선택한 해법
-->

- 제약 조건:
  - `N`, `M`은 최대 `100`으로 매우 작지만, 최단 거리를 구해야 하므로 모든 경로를 탐색하는 DFS보다는 **BFS(너비 우선 탐색)**가 훨씬 효율적이다.
- 단순 접근의 한계:
  - 단순히 방문한 노드 개수를 세는 방식(`count++`)은 모든 탐색 경로의 합을 구하게 되므로 오답이 된다.
- 선택한 해법:
  - 각 칸에 시작점으로부터의 거리를 기록한다. `BFS`의 특성상 특정 칸에 처음 도달했을 때의 값이 항상 최단 거리임을 보장한다.

<br>

### Approach

---

<!--
- 실제로 채택한 알고리즘
- 자료구조 선택 이유
- 단계별 처리 방식
-->

- 알고리즘: `BFS` (너비 우선 탐색)

- 자료구조 선택 이유:
  - `int[][] maze`: 미로 정보를 저장함과 동시에, 방문한 칸에 거리를 직접 갱신하여 별도의 `dist` 배열이나 `visited` 배열 없이 메모리를 절약한다.

  - `ArrayDeque`: `LinkedList`보다 메모리 효율이 좋고 속도가 빠른 큐 구현체를 선택했다.

- 단계별 처리 방식:
  - `(0, 0)` 지점에서 `BFS`를 시작한다.

  - 상하좌우(`dx`, `dy`)를 확인하며 이동 가능한 칸(`1`인 칸)을 찾는다.

  - 다음 칸의 값을 `현재 칸의 값 + 1`로 갱신하여 거리를 누적한다.

  - 목적지 `(N-1, M-1)`에 도달하면 탐색을 종료하고 해당 칸의 값을 출력한다.

<br>

### Complexity

---

- Time complexity: `O(N * M)`
  - 미로의 모든 칸을 최대 한 번씩 방문하므로 가로와 세로 길이에 비례한다.

- Space complexity: `O(N * M)`
  - 미로 데이터를 저장하는 2차원 배열과 `BFS` 큐에 저장되는 좌표 데이터가 공간을 차지한다.

<br>

### Code (Java)

---

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    static int[][] maze;

    public static void main(String[] args) throws Exception {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        maze = new int[N][M];      // 0으로 초기화됨

        // 미로 생성
        for (int i = 0; i < N; i++) {
            String[] positions = br.readLine().split("");

            for (int j = 0; j < M; j++) {
                maze[i][j] = Integer.parseInt(positions[j]);
            }
        }

        bfs(0, 0);

        System.out.print(maze[N-1][M-1]);
    }

    public static void bfs(int initX, int initY) {

        Deque<int[]> q = new ArrayDeque<>();

        // 큐에 넣음 (거리 = 1)
        q.offerLast(new int[]{initX, initY});

        // 방향
        int[] dx = {-1, 1, 0, 0};
        int[] dy = {0, 0, -1, 1};

        // 인접 경로 탐색
        while (!q.isEmpty()) {

            int[] position = q.pollFirst();
            int currX = position[0];
            int currY = position[1];

            // 도착했다면 종료
            boolean arrived = currX == maze.length-1 && currY == maze[0].length-1;
            if (arrived) {
                break;
            }

            // 도착하지 않았다면 인접 경로 탐색
            for (int i = 0; i < 4; i++) {
                int nextX = currX + dx[i];
                int nextY = currY + dy[i];

                if (canMove(nextX, nextY)) {
                    // 거리 갱신
                    maze[nextX][nextY] = maze[currX][currY] + 1;

                    // 큐에 추가
                    q.offerLast(new int[]{nextX, nextY});
                }
            }
        }
    }

    public static boolean canMove(int x, int y) {
        // 미로를 벗어남
        boolean outOfMaze = x < 0 || y < 0 || x >= maze.length || y >= maze[0].length;
        if (outOfMaze) {
            return false;
        }

        // 이동할 수 없는 경로
        if (maze[x][y] == 0) {
            return false;
        }

        // 이미 방문한 경로
        if (maze[x][y] != 1) {
            return false;
        }

        return true;
    }
}
```
