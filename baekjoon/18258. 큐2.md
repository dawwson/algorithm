> 풀이 날짜 : 2026.01.06  
> 문제 유형 : 큐  
> 문제 제목 : 큐2  
> 문제 링크 : https://www.acmicpc.net/problem/18258

<br>

### Intuition

---

- 이 문제는 큐의 기본 연산(`push`, `pop`, `size`, `empty`, `front`, `back`)을 그대로 구현하는 문제이다.

- 명령의 개수 `N`이 최대 `2,000,000`까지 주어지므로, 각 명령을 처리하는 시간이 `O(1)`이 아니면 시간 초과가 발생할 수 있다.

- 단순히 `List` 기반으로 구현할 경우, 앞에서 원소를 제거하는 연산이 `O(n)`이 되어 비효율적이다.

  - 따라서 앞/뒤 삽입·삭제가 모두 `O(1)`인 자료구조가 필요하다고 판단했다.
  - `Java`에서 이를 만족하는 표준 자료구조는 `Deque`이며, 구현체 중 배열 기반으로 빠른 성능을 보장하는 `ArrayDeque`를 사용하기로 했다.
    - `ArrayDeque`는 배열 기반 구조로 연속된 메모리를 사용해 캐시 효율이 높고 객체 생성 비용이 없어, 대량의 큐 연산에서 다른 구현체보다 실제 실행 속도가 빠르다.

<br>

### Approach

---

- 자료구조

  - `Deque<Integer>`
  - 큐의 앞(`front`)은 Deque의 앞(`first`), 큐의 뒤(`back`)는 `Deque`의 뒤(`last`)로 대응시킨다.

- 명령별 처리 방식은 다음과 같다.

  - `push X` : `addLast(X)` → 큐의 뒤에 원소 추가
  - `pop` : `pollFirst()` → 큐의 앞 원소 제거 및 출력
  - `front` : `peekFirst()` → 큐의 앞 원소 조회
  - `back` : `peekLast()` → 큐의 뒤 원소 조회
  - `size` : `size()` 반환
  - `empty` : `isEmpty()` 여부로 판단

- 모든 연산은 덱의 양 끝에서만 수행되므로 각 명령을 입력 순서대로 즉시 처리한다.

- 출력이 많은 문제이므로 `StringBuilder`를 사용해 출력 성능을 개선한다.

<br>

### Complexity

---

- Time complexity: `O(N)`

  - 각 명령은 `Deque`의 연산(`addLast`, `pollLast`, `peekFirst`, `peekLast`)으로 처리된다.
  - 이 연산들은 모두 `O(1)`에 수행된다.
  - 명령이 `N`개이므로 전체 시간복잡도는 `O(N)`이다.

- Space complexity: `O(N)`

  - 큐에 최악의 경우 `N`개의 정수가 저장될 수 있다.
  - 그 외에 사용하는 변수들은 상수 공간이므로 전체 공간복잡도는 `O(N)`이다.

<br>

### Code (Java)

---

```java
import java.util.*;
import java.lang.*;
import java.io.*;

class Main {
    public static void main(String[] args) throws Exception {

        // 입출력 스트림 생성
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        StringBuilder sb = new StringBuilder();

        // 명령 수
        int N = Integer.parseInt(st.nextToken());

        Deque<Integer> queue = new ArrayDeque<>();

        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());

            String command = st.nextToken();

            switch (command) {
                case "push":
                    queue.addLast(Integer.parseInt(st.nextToken()));
                    break;
                case "pop":
                    if (queue.isEmpty()) {
                        sb.append(-1 + "\n");
                    } else {
                        sb.append(queue.pollFirst() + "\n");
                    }
                    break;
                case "size":
                    sb.append(queue.size() + "\n");
                    break;
                case "empty":
                    if (queue.size() == 0) {
                        sb.append(1 + "\n");
                    } else {
                        sb.append(0 + "\n");
                    }
                    break;
                case "front":
                    if (queue.isEmpty()) {
                        sb.append(-1 + "\n");
                    } else {
                        sb.append(queue.peekFirst() + "\n");
                    }
                    break;
                case "back":
                    if (queue.isEmpty()) {
                        sb.append(-1 + "\n");
                    } else {
                        sb.append(queue.peekLast() + "\n");
                    }
                    break;
            }
        }

        System.out.print(sb);
    }
}
```
