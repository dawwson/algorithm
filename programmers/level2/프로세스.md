> 풀이 날짜 : 2026.01.05  
> 문제 유형 : 스택/큐  
> 문제 제목 : 프로세스  
> 문제 링크 : https://school.programmers.co.kr/learn/courses/30/lessons/42587

<br>

### Intuition

---

- 문제의 핵심 요구사항

  - 문제의 실행 규칙은 운영체제의 프로세스 스케줄링을 그대로 시뮬레이션하는 형태이다.

    - 항상 큐의 맨 앞 프로세스를 확인한다.
    - 더 높은 우선순위가 존재하면 다시 큐 뒤로 보낸다.
    - 그렇지 않으면 실행하고 제거한다.

  - 정렬된 결과를 구하는 문제가 아니라 상태가 계속 변하는 큐를 시뮬레이션하는 문제라고 판단했다.

- 단순히 우선순위를 정렬해서 처리할 수 없는 이유

  - 출력 여부는 **현재 큐에 남아 있는 프로세스**들을 기준으로 결정된다.
  - 하나의 프로세스가 실행되면 전체 상태가 바뀌므로, 정적인 정렬 결과는 의미가 없다.
  - 매 단계마다 **현재 프로세스의 우선순위가, 지금 남아 있는 프로세스 중 최댓값인지 여부**를 판단해야 한다.

- 따라서 순서를 유지하며 앞에서 꺼내고 뒤로 보내는 구조(`Queue`)와 현재 기준 최댓값을 빠르게 확인하는 구조(`PriorityQueue`)가 필요하다.
  - 특정 프로세스를 추적해야 하므로 인덱스 정보 보존 필요

<br>

### Approach

---

- 자료구조

  - `Queue<int[]>`
    - 프로세스의 순서 유지 및 회전을 그대로 구현하기 위함이다.
    - `[index, priority]` 형태로 저장하여 위치 정보를 함께 관리한다.
  - `PriorityQueue<Integer>` (내림차순)
    - 현재 큐에 남아 있는 프로세스 중 최대 우선순위 조회를 `O(1)`에 수행하기 위함이다.
    - 프로세스가 실행될 때마다 동적으로 상태를 갱신한다.

- 처리 단계
  - 모든 프로세스를 (인덱스, 우선순위) 형태로 큐에 삽입한다.
  - 모든 우선순위를 우선순위 큐에 삽입한다.
  - 큐가 빌 때까지 다음을 반복한다.
  - 큐의 맨 앞 프로세스를 하나 꺼낸다.
  - 해당 프로세스의 우선순위가 `pq.peek()`와 같다면 실행한다.
    - 실행 순서를 증가시킨다.
    - 우선순위 큐에서도 해당 우선순위를 제거한다.
    - 만약 이 프로세스의 인덱스가 `location`이라면 결과를 반환한다.
    - 그렇지 않다면, 해당 프로세스를 다시 큐의 뒤에 넣는다.
  - 목표 프로세스가 실행될 때의 순서를 반환한다.

<br>

### Complexity

---

- Time complexity: `O(n log n`

  - 우선순위 큐 초기 삽입: `n`번 × `O(log n)`
    - `Java`의 `PriorityQueue`는 힙으로 구현되어 있으며, 삽입 시 힙 성질을 유지하기 위해 최악의 경우 트리 높이(`log n`)만큼 원소를 이동시키므로 `offer` 연산의 시간복잡도는 `O(log n)`이다.
  - 각 프로세스는 최대 한 번 실행되며, 실행 시 `pq.poll()` 발생 ➡️ `O(log n)`
  - 큐의 `poll`, `offer` 연산은 모두 `O(1)`
  - 전체 시간복잡도는 우선순위 큐 연산이 지배하므로 `O(n log n)`으로 평가한다.

- Space complexity: `O(n)`

  - 큐에 최대 `n`개의 프로세스 저장
  - 우선순위 큐에 최대 `n`개의 우선순위 저장

<br>

### Code (Java)

---

```java
import java.util.*;

class Solution {
    public int solution(int[] priorities, int location) {

        Queue<int[]> queue = new LinkedList<>();
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());

        for (int i = 0; i < priorities.length; i++) {
            queue.offer(new int[]{i, priorities[i]});
            pq.offer(priorities[i]);
        }

        int order = 0;

        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int idx = cur[0];
            int priority = cur[1];

            // 현재 문서가 가장 높은 우선순위라면 출력
            if (priority == pq.peek()) {
                pq.poll();
                order++;

                if (idx == location) {
                    return order;
                }
            } else {
                // 아니면 다시 큐 뒤로
                queue.offer(cur);
            }
        }

        return order;
    }
}

```
